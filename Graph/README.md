# Graph Challenges
The repsitory contains the problems related to graphs I have tried to solve on the leetcode [website](https://leetcode.com/problemset/all/)

### Redundant connection II
The goal is to find, in rooted directed tree, the edge that is redundant. If there are several possible solutions return the one that occurs last in the given edge array.  
My approach is to:
 1. Build the tree by storing parents for each node
 2. If there exists a node with two parents then focus on it and find the edge that can be removed.
 3. If not reverse iterate through the list of edges and find the one that create a cycle  
 
I tried to solve this problem using the C++ language. [Problem link](https://leetcode.com/problems/redundant-connection-ii/)  
As of August 4<sup>th</sup>, 2019:
- [x] Find a first working solutionn on the sample input.
- [X] Submit solution. Got wrong
- [x] Find a second working solution on the sample input
- [x] Submit solution. Got correct in 12 ms with 11.9 MB
- [x] Find a faster solution. I used Union Find structure
- [x] Submit solution. Got correct in 8 ms with 10 MB
- [X] Problem solved

### Binary Tree Maximum Path Sum
The goal is to find, in a rooted binary tree, the path whose node values sum up
to the highest value.  
This problem featured in the the [30-day leetcoding of April
2020](https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/)  
I tried to solve this problem using the C++ and Python languages. [Problem
link](https://leetcode.com/problems/binary-tree-maximum-path-sum/)  
As of April 29<sup>th</sup>, 2020:
- [x] Find a first working solutionn on the sample input.
- [x] Submit solution. Got correct in 24 ms with 25.1 MB
- [x] Find a cleaner solution
- [x] Submit solution. Got correct in 24 ms with 25.3 MB
- [X] Retry the problem using Python language for the 30-day of leetcoding of
      April 2020. The solution compute for the maximum path sum at any node in
      the binary tree. My solution visits each node at most once so runtime
      complexity is O(N). To run through the tree I use a DFS thus the space
      complexity of the algorithm is the space of the recursive call stack which
      is proportional to the height of the tree O(h) =  O(log N).
- [X] Submit solution. Got correct in 92 ms with 20.2 MB
- [x] Problem solved

### Sum Root to Leaf Numbers
The goal is to create a function that compute the sum of all the numbers
generated by paths going from root to leaves of a binary tree.  
I tried to solve this problem using the C, C++ and Python languages. [Problem
link](https://leetcode.com/problems/sum-root-to-leaf-numbers/submissions/)  
As of June 29<sup>th</sup>, 2019:
- [x] Find a first working solutionn on the sample input.
- [x] Submit solution. Got correct in 4 ms with 7.7 MB
- [x] Rewrite the solution to go faster.
- [x] Submit solution. Got correct in 0 ms with 7.6 MB
- [x] Write the solution in C++
- [x] Submit the solution. Got correct in 4 ms with 12.4 MB
- [X] Re-implement a solution in Python. I used a recursive DFS approach to do
      this. Going down a level in the recursion I multiply the current value by
      10 and add the value of the current node. Whenever we reach a leaf I store
      the result in the class variable that holds the result. The algorithm runs
      in O(N) since we visit every node in the tree. The space complexity of
      this approach is O(log N) for the recursive call stack.
- [X] Submit solution. Got corect in 32 ms with 14.1 MB
- [X] Implement the Morris graph run-through to be more memory efficient. The
      runtime complexity does not change but now the extra space needed is
      constant O(1).
- [X] Submit solution. Got correct in 36 ms with 13.9 MB
- [x] Problem solved

### Number of Islands
The goal of this challenge is to code a function that finds the number of
islands in a matrix of 0s and 1s where 1 is earth and 0 is water. Is considered
an island earth that is not connected vertically nor horizontally to another
chunk of earth.  
The problem featured in the [30-day leetcoding of April
2020](https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/)  
I tried to solve this problem using the C++ and Python languages[Problem
link](https://leetcode.com/problems/number-of-islands/submissions/)  
As of April 17<sup>th</sup>, 2020:
- [x] Write a solution that works on sample input
- [x] Submit solution. Got wrong
- [x] Write a solution that works for edge cases
- [x] Submit solution. Got right in 76 ms with 15.4 MB
- [X] Solve again the problem in 30-day of leetcoding. Wrote in Python using a
      BFS approach. The algorithm would go over every element in the grid and
      once land (ie: 1) is found then do a BFS to discover all the island. The
      solution runs in O(N*M) since all the elements are going to be visited and
      it needs O(min(N, M)) extra space for the queue.
- [X] Submit solution. Gor correct in 268 ms with 16.5 MB
- [x] Problem solved

### Diameter of Binary Tree
The goal of this challenge is to implement a function that compute diameter of a
Binary Tree which is the longest path between two nodes of the tree.  
This problem featured in the the [30-day leetcoding of April
2020](https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/)  
I tried to solve this problem using the C++ and Python languages [Problem
link](https://leetcode.com/problems/diameter-of-binary-tree/)  
As of April 11<sup>th</sup>, 2020:
- [X] Write a first solution. This solution will simply find the deepest
      children of both the left and right subtrees of the root and, at the root,
      simply add the length of those 2 paths. The time complexity of this
      algorithm is O(N) since all the nodes of the tree are visited. It is O(N)
      extra space complexity considering the recursive call stack.
- [X] Submit solution. Got wrong answer. Should consider the fact that the
      longest path may not go through the root, Dummy !
- [X] Rewrite the solution to take into account the aforementioned problem.
- [X] Submit solution. Got correct in 8 ms with 19 MB
- [X] Reimplement solution in Python for the 30-day of leetcoding. Used the DFS
      approach.
- [X] Submit solution. Got correct in 44 ms with 15.2 MB
- [X] Problem solved

### Flip Equivalent of Binary Tree
The goal of the challenge is to check is 2 Binary Trees are equivalent up to
some flips. A flip is just a swapping a the right child with the left child of a
node.  
I tried to solve this problem using the C++ and Rust language [Problem
link](https://leetcode.com/problems/flip-equivalent-binary-trees)  
As of March 13<sup>th</sup>, 2020:
- [X] Find a first working solution. A recursive algortihm that will check every
      node a the trees in a dfs manner to see if each node is equivalent. The
      algorithm runs in O(min(N1, N2)) as every node in the smallest tree will
      be visited, it will stop before visiting the rest of the nodes of the
      largest tree should there be one. It runs with O(min(N1, N2)) extra space
      as, again, there will as many recursive calls as there are nodes in the
      smallest tree.
- [X] Submit solution. Got correct in 0 ms with 11 MB
- [X] Write a new solution using canonical representation of a binary tree. In
      this approach I am ordering children of each node before comparing them.
      The run time complexity remains O(min(N1, N2)) as the recursion go as far
      as the smallest tree. Same for the space complexity.
- [X] Submit solution. Got correct in 0 ms with 2.2 MB
- [X] Problem solved

### Count Complete Tree Nodes
The goal of this problem is to implement a function that would count the number
of nodes in a complete binary tree.  
I tried to solve this problem using the C++ and Python languages [Problem
link](https://leetcode.com/problems/count-complete-tree-nodes/)  
As of June 23<sup>rd</sup>, 2020:
- [X] Find a first working solution. I decided to implement a binary search to
      find the number of nodes in the last level since in a complete binary tree
      the nodes of the last level are as far left as possible. With this
      solution I would be able to compute the number of nodes in O((log N) ^ 2).
      There is no need for extra memory space so it is O(1) space complexity
- [X] Submit solution. Got wrong, my implementation got too complicated and
      untractable. I need to simplify things.
- [X] Find a better implementation. This time I based my algorithm on the index
      of the leaf node to do the binary search.
- [X] Submit solution. Got correct in 32 ms with 26.2 MB
- [X] Reimplement an binary search approach in Python as part of the June
      leetcoding challenge. The approach I used was the same as before.
- [X] Submit solution. Got correct in 92 ms with 21.4 MB
- [X] Problem solved
  
### Construct BST from Preorder Traversal
The goal of this challenge is to implement a function that would take a BST in
the form of preorder traversal list and return the reconstructed BST.  
This problem featured in the the [30-day leetcoding of April
2020](https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/)  
I tried to solve this problem using the C++ and Python languages [Problem
link](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/)  
As of May 23<sup>rd</sup>, 2020:
- [X] Find a first working solution. After scratching my head I came up with a
      recursive solution that runs through the array once so the time complexity
      is O(N). The recursive stack will need at most O(N) extra space
- [X] Submit solution. Got correct in 4 ms with 12 MB
- [X] Resolve the problem in Python as part of the May leetcoding challenge. I
      managed to correctly rewrite the solution from scratch. The run-time
      complexity of the solution is still O(N) since I need to run through all
      the elements of the array. The space complexity is still O(N) in the edge
      case the tree is actually a degenerated line.
- [X] Submit solution. Got correct in 28 ms with 14 MB
- [X] Problem solved

### Check if a string is a valid sequence from root to leaves path in a binary tree
The goal of this challenge is to implement some kind of prefix tree with binary
string in a binary tree. The goal is, given a binary string, to check whether it
exists in the given binary tree starting from root to leave.  
This problem featured in the the [30-day leetcoding of April
2020](https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/)  
I tried to solve this problem using the Python language [Problem
link]()  
As of April 30<sup>th</sup>, 2020:
- [X] Find a first working solution. I used a DFS approach to check if the array
      is valid node by node. For each character in the string I check at most
      two nodes of the tree. The runtime complexity is therefore O(2 * S) = O(S)
      where S is the size of the string. The extra-space needed is O(min(S, log
      N)) for the recursive callstack.
- [X] Submit solution. Got correct 100 ms with 15.3 MB
- [X] Problem solved

### Counsins in Binary Tree
The goal of this problem is to determine if two given values are associated with
cousin nodes in a given binary tree. Cousin nodes should have the same depth but
not the same parent.  
I tried to solve this problem using the Python and Rust languages [Problem
link](https://leetcode.com/problems/cousins-in-binary-tree/)  
As of May 8<sup>th</sup>, 2020:
- [X] Find a first working solution. I run through all nodes in the tree storing
      the parent and depth of wanted nodes in a storage, in this case a hashmap.
      Since I run through each node at the worst the run time complexity is
      O(N). Extra space needed is O(N) for recursive call stack for the DFS.
- [X] Submit solution. Got correct in 36 ms with 13.8 MB
- [X] Use a second faster solution. It consists in a BFS on the tree with early
      stop if answer is found. In the worst case we still need to run through
      every node in the tree, so the runtime complexity remais O(N). Space
      needed is still O(N).
- [X] Submit solution. Got correct in 0 ms with 2.1 MB
- [X] Problem solved.

### Find the town judge
The goal of this challenge is to determine who is the judge in a town with
individuals represented as integers and given certain trust relationship between
two individuals.  
I tried to solve this problem using the C language [Problem
link](https://leetcode.com/problems/find-the-town-judge/submissions/)  
As of May 11<sup>th</sup>, 2020:
- [X] Find a first working solution. My first approach was completely wrong as I
      decided to use disjoint sets. But it quickly appeared obvious that I
      needed to take into account the directed character of the trust
      relationships. Thus I used an array to store the difference between the
      outbound and the inbound degrees. The individual with the difference = N-1
      would be the town judge. The algorithm runs in O(E) where E is the number
      of trust relationships. I need O(N) extra space to store the degree
      difference for each person.
- [X] Submit solution. Got correct in 160 ms with 15.8 MB
- [X] Problem solved

### Find the celebrity
The goal of this challenge is to find, if they exist, the celibrity in a given
group of people labelled from 0 to n - 1. The algorithm should rely on an API to
know about the knows relationship between 2 given people.  
I tried to solve this problem using the C++ language [Problem
link](https://leetcode.com/problems/find-the-celebrity)  
As of May 11<sup>th</sup>, 2020:
- [X] Find a first working solution. I first used a brute-force solution that
      would collect all the relationships and conclude to the result by
      examining the difference between in and out degree. The algorithm runs in
      O(N<sup>2</sup>) time and needs O(N) space to store the difference between
      degrees.
- [X] Submit solution. Got Time Limit Exceeded
- [X] Find another solution. This time let us think about the problem. Starting
      from 0, our candidate celebrity, we can check if this candidate does not
      know the other people. If we find a people i that the candidate knows then
      i becomes our new candidate. Indeed, all numbers from 0 to i cannot be
      celebrity as 0 does not know them. We follow the same process for people
      i+1 to n. Once this process is over we have a viable candidate k to be the
      celebrity. However, we still need to check that they do not know anyone
      between 0 and k, and that everyone knows him/her. If this check fails then
      there is no celebrity otherwise the celebrity is k.
      The algorithm needs to run twice over the people, so O(2 * N) = O(N) where
      N is the number of nodes in the graph. No extra space is needed.
- [X] Submit solution. Got correct in 116 ms with 9.7 MB
- [X] Problem solved.

### K-th smallest element in a BST
The goal of this challenge is to find the k<sup>th</sup> element in a given
Binary Search Tree.  
I tried to solve this problem using the C++ language [Problem
link](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)  
As May 22<sup>nd</sup>, 2020:
- [X] Find a first working solution. Using the property of the BST, I decided to
      just run through the whole binary tree returning an array corresponding to
      an in-order traversal of the tree. This is also a sorted array. What
      remains is just to return the k element of the array. Since I need to go
      through each node of the BST to construct the array of in-order traversal,
      the runtime of the algorithm is O(N) and I need O(N) extra space.
- [X] Submit solution. Got correct in 43 ms with 33 MB
- [X] There is a faster algorithm that runs in O(log N) to be implemented. Using
      iterative solution we can stop as soon as we find the k<sup>th</sup>
      element in the tree. Thus improving the runtime of the algorithm to O(H) =
      O(log N) and the space complexity to O(H) = O(log N) as well.
- [X] Submit solution. Got correct in 20 ms with 24.4 MB
- [X] Problem solved

### Possible bipartition
The goal of this challenge is to check whether a graph of people is bipartite.
We are given dislike relationships between nodes (ie: people) which means the 2
nodes linked by this relationship cannot be put together in the same group.
Basically, we need to check if these dislike relationships define a good
bipartition of people.  
I tried to solve this problem using the Python language [Problem
link](https://leetcode.com/problems/possible-bipartition/)  
As of May 28<sup>th</sup>, 2020:
- [X] Find a first working solution. I just use the bipartition check algorithm
      that is based on BFS. For each non visited nodes we start a BFS assigning
      colors to nodes. The first is assigned black and then all its adjacent
      nodes are assigned red. Then, going down in the BFS, the red nodes
      adjacent nodes will be assigned black. If an adjacent node was already
      visited and assigned the same color as the current node then it means the
      graph cannot be bipartite.
- [X] Submit solution. Got correct in 912 ms with 18.6 MB
- [X] Problem solved

### Course Schedule
The goal of this challenge is to check whether, given a list of course
dependencies, it is possible to do all the courses. In other words, the goal is
to check if there is no cycle in a graph of courses prerequisites.  
I tried to solve this problem using the C++ language [Problem
link](https://leetcode.com/problems/course-schedule/)  
As of June 9<sup>th</sup>, 2020:
- [X] Find a first working solution. In order to solve this problem I used a DFS
      on the graph. For each node I push it on a stack structure along with its
      list of parents. As soon as an already visited parents is found in a
      adjacency list then we know there is a cycle. To avoid checking same path
      several times I remove the edges already visited. Indeed, there is no need
      in visiting a sub tree again if we already know it does not contain
      cycles. Since I go through each edge and each node in the graph the
      runtime complexity of this algorithm is O(N + E). I need O(N + E) map to
      store the adjacency lists.
- [X] Submit solution. Got correct in 1488 ms with 684.7 MB which is quite a
      lot.
- [X] Optimize solution. By writing it recursively and using an array or bool
      instead of a hash table for storing already seen value, the code seems to
      run faster and is much clearer. However I doubt it is thread safe in that
      case. The runtime and space complexity remain the same.
- [X] Submit solution. Got correct in 40 ms with 13.1 MB
- [X] Code a new solution this time using Topological Sort and the Khan
      algorithm. Since we still need to go through each eadge and each node the
      complexity is still O(N + E), and we also need to store O(N + E) objects.
- [X] Submit solution. Got correct in 40 ms with 13.3 MB
- [X] Problem solved

### Invert Binary Tree
The goal of this challenge is to invert a given binary tree, which means
switching the left child of node with its right child.  
I tried to solve this problem using the C++ language [Problem
link](https://leetcode.com/problems/invert-binary-tree/)  
As of June 1<sup>st</sup>, 2020:
- [X] Find a first working solution. I just did a simple bfs over the tree
      switching the two children of every node. The runtime complexity of this
      algorithm is O(N) since I need to go through every node of the tree and
      the space complexity is also O(N) since I need to store the nodes of the
      BFS in a queue.
- [X] Submit solution. Got correct in 0 ms with 8.7 MB
- [X] Problem solved

### Count of smaller number after self
The goal of this challenge is, given an array of integers, for each element in
the array, count the number of integers that are smaller than this element and
placed after it in the array. In other words, for an array A we should return B
where B[i] = Card {A[j] | j > i and A[j] <= A[i]}  
I tried to solve this problem using the Rust language [Problem
link](https://leetcode.com/problems/count-of-smaller-numbers-after-self/)  
As of June 5<sup>th</sup>, 2020:
- [X] Find a first working solution. Seeing that the naive approach that would
      run in O(N<sup>2</sup>) is not accepted then we need to be smarter. Using
      the related topics tag as guidance. I decided to go for a BIT to count the
      number of element that are smaller in an ordered index array. This
      solution has a runtime complexity of O(N log N) and needs O(3*N) = O(N) extra
      space.
- [X] Submit solution. Got correct in 4 ms wiht 3 MB
- [ ] Implement in python another possible approach for this problem (ie: Merge Sort, BST)
- [X] Problem solved

### Cheapest fligths within K stops
The goal of this problem is to determine the cheapest itinerary to go from a
city of origin to a destination city using a given network of flights and at
most K stops to reach the destination.  
I tried to solve this problem using the C++ language [Problem
link](https://leetcode.com/problems/cheapest-flights-within-k-stops/)  
As of June 14<sup>th</sup>, 2020:
- [X] Find a first working solution. I decided to go for a somewhat Breadth
      First Search approach to compute the shortest path in the weighted graph
      of flights. Starting from the sources we follow every edges in the graph
      until every paths contains K vertices. This could mean that we can visit
      same edge several times. Cycles are not problem with this approach as we
      stop after K iterations anyway. During this process, everytime we reach
      the destination node we update the result accordingly if the path found is
      cheaper. Since every edges of the graph can be visited K times then the
      runtime complexity of the algorithm is O(E * K). I store the distances in
      a N * K matrix and I build adjacency dictionary thus the space complexity
      is O(N * K + E)
- [X] Submit solution. Got correct in 96 ms with 11.9 MB
- [ ] Implement another solution (BFS by level, Dijkstra, Bellman-Ford)
- [X] Problem solved.

### Search in a Binary Search Tree
The goal of this challenge is to search for a value in a given Binary Search
Tree. The function should return the root of the subtree at the given value. If
the value does not exist in the tree then return NULL.  
I tried to solve this problem using the Python language [Problem
link](https://leetcode.com/problems/search-in-a-binary-search-tree/)  
As of June 15<sup>th</sup>, 2020:
- [X] Find a first working solution. The algorithm to code is just to search
      through the BST. Move to the left if the value of the current node is
      bigger than the searched value, move to the right if the searched value
      is bigger than the current node's value and return the current node if the
      node is None or if the value of the node equals that that is searched. The
      runtime complexity of the algorithm is O(log N) where N is the number of
      nodes in the tree. Since the solution in recursive the extra space needed
      is that of the recursive call stack, that is to say O(log N).
- [X] Submit solution. Got correct in 88 ms with 15.8 MB
- [X] Problem solved

### Word Search II
The goal of this challenge is to find in a given dictionary of words which of
those words are present in a board of letters. That is to say, which words can
be constructed by walking a path of adjacent letters in the given board.  
I tried to solve this problem using the C++ language [Problem
link](https://leetcode.com/problems/word-search-ii/)  
As of June 30<sup>th</sup>, 2020:
- [X] Find a first working solution. I went for the approach of backtracking
      here, using a Trie to store the words, as I walk the path of letters in
      the board I also walk a path in the Trie. Whenever, we reach a leaf node
      in the Trie then we add the word in the result set and set the node isLeaf
      flag to false so that we do not match this word again. The runtime
      complexity of this algorithm is tricky to compute. The complexity of the
      creation of the Trie is O(D * L) where D is the size of the dictionary and
      L is the length of the longest word. We can view the exploration of the
      matrix a the exploration of a tree where each node can have 3 children
      (ie: the three directions to go to an adjacent cell) except for the start
      cell which can have 4 directions. Then the runtime complexity of this
      algorithm is O(N * M * (4 * 3<sup>L - 1</sup>)) where L is the length of
      the longest word. This bounds the runtime complexity. We need extra space
      for the storage of the Trie which needs O(26<sup>L</sup>) at most. Then
      other space is needed for the recursion stack which is O(L).
- [X] Submit solution. Got correct in 156 ms with 39.7 MB
- [ ] Optimize the solution. Maybe by removing Trie nodes after a word was matched.
- [X] Problem solved

### Binary Tree Level Order Traversal II
The goal of this challenge is to output the tree level traversal of a given
binary tree.  
I tried to solve this problem using the Python language [Problem
solved](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/)  
As of July 2<sup>nd</sup>, 2020:
- [X] Find a first working solution. I decided to go for a simple BFS where I
      store the level with the node to be visited in order to add the value at
      the right index in the resulting tree level order traversal. The algorithm
      runs in O(N) as we visit all nodes in the tree and requires O(log N)
      space.
- [X] Submit solution. Got correct in 48 ms with 14.2 MB
- [X] Problem solved.

### Maximum width of binary tree
The goal of this challenge is to compute the maximum width of a binary tree. The
width of a level of the tree is defined as the number of nodes between the
leftmost and the rightmost nodes, counting NULL nodes in between. Thus for each
level we need to compute the width and find the maximum.  
I tried to solve this problem using the C++ language [Problem
link](https://leetcode.com/problems/maximum-width-of-binary-tree/)  
As of June 9<sup>th</sup>, 2020:
- [X] Find a first working solution. My first approach was assign index to each
      node on every level with the index of node located most to the left, be it null or
      not, set to 0. The index is passed down to the children of a node
      following the rule that its left child will have index = curr_index * 2
      and its right child will have index = curr_index * 2 + 1. Then we do a BFS
      by running throught each level at a time and for each level we put the max
      difference between the rightmost index and the leftmost index of non null
      nodes. Since we are visiting all the nodes in the tree the algorithm
      runtime complexity is O(N) and for each level we need to store at most N /
      2 nodes for a complete binary tree thus a space complexity of O(N).
- [X] Submit solution. Got Runtime Error due to integer overflow since the tree
      can be very deep without being very wide the indices increase
      exponentially.
- [X] Find a second solution. This time instead of using indices, I decided to
      use the size of the queue to keep track of the result. Whenever we
      encounter the leftmost non-null node on a level we start filling up the
      queue with null ptr when a node does not exist so as to count the number
      of times we pop a value from the queue in the next level. The runtime
      complexity remains the same as well as the space complexity but as we are
      adding more and more useless values the memory can grow very high.
- [X] Submit solution. Got correct in 1136 ms with 264.2 MB (this is huge)
- [X] Due to those high numbers I decided to give the first approach another try
      by using unsigned long long integers instead of normal integers.
- [X] Submit solution. Got correct in 4 ms with 15.7 MB
- [X] Problem solved.

### Same Tree
The goal of this challenge is to determine if two given binary trees are exactly
the same. That is to say, the two binary tree have the same structure and the
same nodes.  
I tried to solve this problem using the C language [Problem
link](https://leetcode.com/problems/same-tree/)  
As of July 13<sup>th</sup>, 2020:
- [X] Find a first working solution. I went to the recursive solution which for
      each node in the tree will check if both value are equal and if they are
      return the result of the comparison of between the left children and
      between the right children. Since the algorithm runs through every nodes
      then the complexity of this approach is O(N) and the space needed is O(log
      N) for the recursive stack.
- [X] Submit solution. Got correct in 4 ms with 5.6 MB
- [X] Problem solved.

### Surrounded regions
The goal of this challenge is to switch all surrounded 'O' cells to 'X' cells. A
group of cells is considered surrounded if its borders have 'X' cells neighbors
and do not touch the borders of the board.  
I tried to solve this problem using the Python language [Problem
link](https://leetcode.com/problems/surrounded-regions/)  
As of July 14<sup>th</sup>, 2020:
- [X] Find a first working solution. I am using a BFS approach. I scan the board
      in order to find a starting 'O' cell and add it to a queue then I BFS to
      find all the cells in the group. If the group has at least one cell on the
      border of the board then the group in discarded and remains 'O'. To keep
      track of visited cells I use a hashset. The solution is running over all
      cells in the board thus a complexity of O(N * M) and a space complexity of
      O(N * M) as well since I need to store all visited cells.
- [X] Submit solution. Got correct in 788 ms with 21.8 MB
- [X] Keeping the BFS approach but this time trying another angle. Instead of
      looking for good surrounded regions let us search for bad ones. Bad ones
      are obviously located on the borders of the board. Thus, we first build
      the list of cells on the border of the board and if we find an 'O' cell
      then we BFS to determine the full region. By marking the visited cells
      with 'E' we can afterward differentiate them from good region. The
      algorithm runs again in O(N * M) time complexity and we still need O(N *
      M) space for the queue of the BFS.
- [X] Submit solution. Got correct in 300 ms with 15 MB
- [X] Problem solved.

### Course Schedule II
The goal of this challenge is to determine an order to take courses which may
have prerequisites as per the given lists of prerequisites. If an ordering does
not exist then an empty array must be returned.  
I tried to solve this problem using the C++ language [Problem
link](https://leetcode.com/problems/course-schedule-ii/)  
As of July 18<sup>th</sup>, 2020:
- [X] Find a first working solution. I am using the in degrees of the nodes in
      the course graph to determine a topological order of the courses. I am
      first populating an adjacency list and then take in the first nodes whose
      indegree is zero to start the exploration of the graph. As I run through
      every vertex and edges once then the time complexity of this algorithm is
      O(V + E) and the extra space needed is also O(V + E) as I need to store
      the resulting ordered list O(V) and I also need to store all the edges
      O(E).
- [X] Submit solution. Got correct in 76 ms with 13.3 MB
- [X] Problem solved.

### Word Search
The goal of this challenge is to determine if a word exists in a given grid of
letters. The word can be written with any sequence of adjacent letters in the
matrix (above, below, left or right).  
I tried to solve this problem using the C++ language [Problem
link](https://leetcode.com/problems/word-search/)  
As of July 23<sup>rd</sup>, 2020:
- [X] Find a first working solution. I simply run through every letter and
      perform a bfs in the matrix. If ever one of the letter does not match that
      of the word being searched, then I backtrack. The runtime complexity can
      be decomposed in the exploration of the matrix. Basically, at each letter
      we can continue the exploration in 3 possible directions, so 3 different
      choices which can be represented into an explocation tree with
      3<sup>L</sup> nodes. Thus as we apply the dfs on every letter in the
      matrix then the runtime complexity is O(N * 3<sup>L</sup>). We need O(L)
      extra space for the recursive dfs stack.
- [X] Submit solution. Got correct in 92 ms with 20.2 MB
- [X] Problem solved.
