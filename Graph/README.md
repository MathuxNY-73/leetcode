# Graph Challenges
The repsitory contains the problems related to graphs I have tried to solve on the leetcode [website](https://leetcode.com/problemset/all/)

### Redundant connection II
The goal is to find, in rooted directed tree, the edge that is redundant. If there are several possible solutions return the one that occurs last in the given edge array.  
My approach is to:
 1. Build the tree by storing parents for each node
 2. If there exists a node with two parents then focus on it and find the edge that can be removed.
 3. If not reverse iterate through the list of edges and find the one that create a cycle  
 
I tried to solve this problem using the C++ language. [Problem link](https://leetcode.com/problems/redundant-connection-ii/)  
As of August 4<sup>th</sup>, 2019:
- [x] Find a first working solutionn on the sample input.
- [X] Submit solution. Got wrong
- [x] Find a second working solution on the sample input
- [x] Submit solution. Got correct in 12 ms with 11.9 MB
- [x] Find a faster solution. I used Union Find structure
- [x] Submit solution. Got correct in 8 ms with 10 MB
- [X] Problem solved

### Binary Tree Maximum Path Sum
The goal is to find, in a rooted binary tree, the path whose node values sum up
to the highest value.  
This problem featured in the the [30-day leetcoding of April
2020](https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/)  
I tried to solve this problem using the C++ and Python languages. [Problem
link](https://leetcode.com/problems/binary-tree-maximum-path-sum/)  
As of April 29<sup>th</sup>, 2020:
- [x] Find a first working solutionn on the sample input.
- [x] Submit solution. Got correct in 24 ms with 25.1 MB
- [x] Find a cleaner solution
- [x] Submit solution. Got correct in 24 ms with 25.3 MB
- [X] Retry the problem using Python language for the 30-day of leetcoding of
      April 2020. The solution compute for the maximum path sum at any node in
      the binary tree. My solution visits each node at most once so runtime
      complexity is O(N). To run through the tree I use a DFS thus the space
      complexity of the algorithm is the space of the recursive call stack which
      is proportional to the height of the tree O(h) =  O(log N).
- [X] Submit solution. Got correct in 92 ms with 20.2 MB
- [x] Problem solved

### Sum Root to Leaf Numbers
The goal is to create a function that compute the sum of all the numbers generated by paths going from root to leaves of a binary tree.  
I tried to solve this problem using the C and C++ languages. [Problem link](https://leetcode.com/problems/sum-root-to-leaf-numbers/submissions/)  
As of August 12<sup>th</sup>, 2019:
- [x] Find a first working solutionn on the sample input.
- [x] Submit solution. Got correct in 4 ms with 7.7 MB
- [x] Rewrite the solution to go faster.
- [x] Submit solution. Got correct in 0 ms with 7.6 MB
- [x] Write the solution in C++
- [x] Submit the solution. Got correct in 4 ms with 12.4 MB
- [x] Problem solved

### Number of Islands
The goal of this challenge is to code a function that finds the number of
islands in a matrix of 0s and 1s where 1 is earth and 0 is water. Is considered
an island earth that is not connected vertically nor horizontally to another
chunk of earth.  
The problem featured in the [30-day leetcoding of April
2020](https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/)  
I tried to solve this problem using the C++ and Python languages[Problem
link](https://leetcode.com/problems/number-of-islands/submissions/)  
As of April 17<sup>th</sup>, 2020:
- [x] Write a solution that works on sample input
- [x] Submit solution. Got wrong
- [x] Write a solution that works for edge cases
- [x] Submit solution. Got right in 76 ms with 15.4 MB
- [X] Solve again the problem in 30-day of leetcoding. Wrote in Python using a
      BFS approach. The algorithm would go over every element in the grid and
      once land (ie: 1) is found then do a BFS to discover all the island. The
      solution runs in O(N*M) since all the elements are going to be visited and
      it needs O(min(N, M)) extra space for the queue.
- [X] Submit solution. Gor correct in 268 ms with 16.5 MB
- [x] Problem solved

### Diameter of Binary Tree
The goal of this challenge is to implement a function that compute diameter of a
Binary Tree which is the longest path between two nodes of the tree.  
This problem featured in the the [30-day leetcoding of April
2020](https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/)  
I tried to solve this problem using the C++ and Python languages [Problem
link](https://leetcode.com/problems/diameter-of-binary-tree/)  
As of April 11<sup>th</sup>, 2020:
- [X] Write a first solution. This solution will simply find the deepest
      children of both the left and right subtrees of the root and, at the root,
      simply add the length of those 2 paths. The time complexity of this
      algorithm is O(N) since all the nodes of the tree are visited. It is O(N)
      extra space complexity considering the recursive call stack.
- [X] Submit solution. Got wrong answer. Should consider the fact that the
      longest path may not go through the root, Dummy !
- [X] Rewrite the solution to take into account the aforementioned problem.
- [X] Submit solution. Got correct in 8 ms with 19 MB
- [X] Reimplement solution in Python for the 30-day of leetcoding. Used the DFS
      approach.
- [X] Submit solution. Got correct in 44 ms with 15.2 MB
- [X] Problem solved

### Flip Equivalent of Binary Tree
The goal of the challenge is to check is 2 Binary Trees are equivalent up to
some flips. A flip is just a swapping a the right child with the left child of a
node.  
I tried to solve this problem using the C++ and Rust language [Problem
link](https://leetcode.com/problems/flip-equivalent-binary-trees)  
As of March 13<sup>th</sup>, 2020:
- [X] Find a first working solution. A recursive algortihm that will check every
      node a the trees in a dfs manner to see if each node is equivalent. The
      algorithm runs in O(min(N1, N2)) as every node in the smallest tree will
      be visited, it will stop before visiting the rest of the nodes of the
      largest tree should there be one. It runs with O(min(N1, N2)) extra space
      as, again, there will as many recursive calls as there are nodes in the
      smallest tree.
- [X] Submit solution. Got correct in 0 ms with 11 MB
- [X] Write a new solution using canonical representation of a binary tree. In
      this approach I am ordering children of each node before comparing them.
      The run time complexity remains O(min(N1, N2)) as the recursion go as far
      as the smallest tree. Same for the space complexity.
- [X] Submit solution. Got correct in 0 ms with 2.2 MB
- [X] Problem solved

### Count Complete Tree Nodes
The goal of this problem is to implement a function that would count the number
of nodes in a complete binary tree.  
I tried to solve this problem using the C++ language [Problem
link](https://leetcode.com/problems/count-complete-tree-nodes/)  
As of March 31<sup>st</sup>, 2020:
- [X] Find a first working solution. I decided to implement a binary search to
      find the number of nodes in the last level since in a complete binary tree
      the nodes of the last level are as far left as possible. With this
      solution I would be able to compute the number of nodes in O((log N) ^ 2).
      There is no need for extra memory space so it is O(1) space complexity
- [X] Submit solution. Got wrong, my implementation got too complicated and
      untractable. I need to simplify things.
- [X] Find a better implementation. This time I based my algorithm on the index
      of the leaf node to do the binary search.
- [X] Submit solution. Got correct in 32 ms with 26.2 MB
- [X] Problem solved
  
### Construct BST from Preorder Traversal
The goal of this challenge is to implement a function that would take a BST in
the form of preorder traversal list and return the reconstructed BST.  
This problem featured in the the [30-day leetcoding of April
2020](https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/)  
I tried to solve this problem using the C++ language [Problem
link](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/)  
As of April 20<sup>th</sup>, 2020:
- [X] Find a first working solution. After scratching my head I came up with a
      recursive solution that runs through the array once so the time complexity
      is O(N). The recursive stack will need at most O(N) extra space
- [X] Submit solution. Got correct in 4 ms with 12 MB
- [X] Problem solved

### Check if a string is a valid sequence from root to leaves path in a binary tree
The goal of this challenge is to implement some kind of prefix tree with binary
string in a binary tree. The goal is, given a binary string, to check whether it
exists in the given binary tree starting from root to leave.  
This problem featured in the the [30-day leetcoding of April
2020](https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/)  
I tried to solve this problem using the Python language [Problem
link]()  
As of April 30<sup>th</sup>, 2020:
- [X] Find a first working solution. I used a DFS approach to check if the array
      is valid node by node. For each character in the string I check at most
      two nodes of the tree. The runtime complexity is therefore O(2 * S) = O(S)
      where S is the size of the string. The extra-space needed is O(min(S, log
      N)) for the recursive callstack.
- [X] Submit solution. Got correct 100 ms with 15.3 MB
- [X] Problem solved

### Counsins in Binary Tree
The goal of this problem is to determine if two given values are associated with
cousin nodes in a given binary tree. Cousin nodes should have the same depth but
not the same parent.  
I tried to solve this problem using the Python and Rust languages [Problem
link](https://leetcode.com/problems/cousins-in-binary-tree/)  
As of May 8<sup>th</sup>, 2020:
- [X] Find a first working solution. I run through all nodes in the tree storing
      the parent and depth of wanted nodes in a storage, in this case a hashmap.
      Since I run through each node at the worst the run time complexity is
      O(N). Extra space needed is O(N) for recursive call stack for the DFS.
- [X] Submit solution. Got correct in 36 ms with 13.8 MB
- [X] Use a second faster solution. It consists in a BFS on the tree with early
      stop if answer is found. In the worst case we still need to run through
      every node in the tree, so the runtime complexity remais O(N). Space
      needed is still O(N).
- [X] Submit solution. Got correct in 0 ms with 2.1 MB
- [X] Problem solved.

### Find the town judge
The goal of this challenge is to determine who is the judge in a town with
individuals represented as integers and given certain trust relationship between
two individuals.  
I tried to solve this problem using the C language [Problem
link](https://leetcode.com/problems/find-the-town-judge/submissions/)  
As of May 11<sup>th</sup>, 2020:
- [X] Find a first working solution. My first approach was completely wrong as I
      decided to use disjoint sets. But it quickly appeared obvious that I
      needed to take into account the directed character of the trust
      relationships. Thus I used an array to store the difference between the
      outbound and the inbound degrees. The individual with the difference = N-1
      would be the town judge. The algorithm runs in O(E) where E is the number
      of trust relationships. I need O(N) extra space to store the degree
      difference for each person.
- [X] Submit solution. Got correct in 160 ms with 15.8 MB
- [X] Problem solved

### Find the celebrity
The goal of this challenge is to find, if they exist, the celibrity in a given
group of people labelled from 0 to n - 1. The algorithm should rely on an API to
know about the knows relationship between 2 given people.  
I tried to solve this problem using the C++ language [Problem
link](https://leetcode.com/problems/find-the-celebrity)  
As of May 11<sup>th</sup>, 2020:
- [X] Find a first working solution. I first used a brute-force solution that
      would collect all the relationships and conclude to the result by
      examining the difference between in and out degree. The algorithm runs in
      O(N<sup>2</sup>) time and needs O(N) space to store the difference between
      degrees.
- [X] Submit solution. Got Time Limit Exceeded
- [X] Find another solution. This time let us think about the problem. Starting
      from 0, our candidate celebrity, we can check if this candidate does not
      know the other people. If we find a people i that the candidate knows then
      i becomes our new candidate. Indeed, all numbers from 0 to i cannot be
      celebrity as 0 does not know them. We follow the same process for people
      i+1 to n. Once this process is over we have a viable candidate k to be the
      celebrity. However, we still need to check that they do not know anyone
      between 0 and k, and that everyone knows him/her. If this check fails then
      there is no celebrity otherwise the celebrity is k.
      The algorithm needs to run twice over the people, so O(2 * N) = O(N) where
      N is the number of nodes in the graph. No extra space is needed.
- [X] Submit solution. Got correct in 116 ms with 9.7 MB
- [X] Problem solved.

### K-th smallest element in a BST
The goal of this challenge is to find the k<sup>th</sup> element in a given
Binary Search Tree.  
I tried to solve this problem using the C++ language [Problem
link](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)  
As May 22<sup>nd</sup>, 2020:
- [X] Find a first working solution. Using the property of the BST, I decided to
      just run through the whole binary tree returning an array corresponding to
      an in-order traversal of the tree. This is also a sorted array. What
      remains is just to return the k element of the array. Since I need to go
      through each node of the BST to construct the array of in-order traversal,
      the runtime of the algorithm is O(N) and I need O(N) extra space.
- [X] Submit solution. Got correct in 43 ms with 33 MB
- [ ] There is a faster algorithm that runs in O(log N) to be implemented.
- [X] Problem solved
